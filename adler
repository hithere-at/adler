#!/usr/bin/env python
from urllib.request import urlopen
from urllib.parse import quote as urlquote
from os import system
import json

# Input Sanitizer 1: Check if input value is valid and not out of range

def int_prompt(content, err_msgs, range_num=[]):

	while True:

		try:
			augh = int(input(content))
			break

		except ValueError:
			print(err_msgs[0])
			continue

		if range_num[0] <= augh <= range_num[1]:
			break

		else:
			print(err_msgs[1])
			continue

	return augh

# URL constants and SHA256 hashes for fetching query results and stream links
QUERY_HASH = "b645a686b1988327795e1203867ed24f27c6338b41e5e3412fc1478a8ab6774e"
STREAM_HASH = "0ac09728ee9d556967c1a60bbcf55a9f58b4112006d09a258356aeafe1c33889"

SEARCH_URL_VARIABLES = '{%22search%22:{%22query%22:%22<QUERY>%22,%22allowAdult%22:false,%22allowUnknown%22:false},%22limit%22:26,%22page%22:1,%22translationType%22:%22sub%22,%22countryOrigin%22:%22ALL%22}'
STREAM_URL_VARIABLES = '{%22showId%22:%22<ANIME_ID>%22,%22translationType%22:%22sub%22,%22episodeString%22:%22<EPISODE>%22}'

URL_EXTENSIONS = '{%22persistedQuery%22:{%22version%22:1,%22sha256Hash%22:%22<HASH>%22}}'

# START
query = input("\033[1;35mAnime name:\033[0m ")
print("", end="\n")
query = urlquote(query)

url_variables = SEARCH_URL_VARIABLES.replace("<QUERY>", query)
url_extensions = URL_EXTENSIONS.replace("<HASH>", QUERY_HASH)

fetch_url = "https://api.allanime.to/allanimeapi?variables=" + url_variables + "&extensions=" + url_extensions

# Fetch query reuslts and the anime info
resp = json.loads(urlopen(fetch_url).read().decode())
shows = resp["data"]["shows"]["edges"]

# List of AllAnime anime id's, name, and current subbed episode (used to fetch stream links and display anime's name to user)
ids_and_titles = [[z["_id"], z["name"], z["availableEpisodes"]["sub"]] for z in shows]

for x, y in enumerate(ids_and_titles, 1):
	print(f"\033[1;36m[{x}]\033[0m \033[1;34m{y[1]}\033[0m")

chosen_one = int_prompt("\033[1;35mSelect anime (with numbers):\033[0m ", ["\033[1;31mError: Invalid numbers\033[0m\n", "\033[1;31mError: Selection out of range\033[0m\n"], range_num=[1, len(ids_and_titles)])
chosen_one -= 1

# List of seleted anime ID's, name, and current subbed spisode
anime_info = ids_and_titles[chosen_one]

episode = int_prompt(f"\033[1;35mSelect episode [1-{anime_info[2]}]:\033[0m ", ["\033[1;31mError: Invalid input\033[0m\n", "\033[1;31mError: Episode out of range\033[0m\n"], range_num=[1, anime_info[2]])

# Replace URL templates with the corresponding inputs
url_variables = STREAM_URL_VARIABLES.replace("<ANIME_ID>", anime_info[0])
url_variables = url_variables.replace("<EPISODE>", str(episode))

url_extensions = URL_EXTENSIONS.replace("<HASH>", STREAM_HASH)

fetch_url = "https://api.allanime.to/allanimeapi?variables=" + url_variables + "&extensions=" + url_extensions

print("", end="\n")

# Fetch and sort stream links
resp = json.loads(urlopen(fetch_url).read().decode())
stream_links = resp["data"]["episode"]["sourceUrls"]
stream_links = sorted(stream_links, key=lambda x: x['priority'], reverse=True)

# List of stream sources with their URL, name, and download link (if any)
name_and_links = [[z["sourceUrl"], z["sourceName"], z.get("downloads")] for z in stream_links]

for x, y in enumerate(name_and_links, 1):
	print(f"\033[1;36m[{x}]\033[0m \033[1;34m{y[1]}\033[0m")

# Ask user for selected source and action
source = int_prompt(f"\033[1;35mSelect source [1-{len(name_and_links)}]:\033[0m ", ["\033[1;31mError: Invalid input\033[0m\n", "\033[1;31mError: Source out of range\033[0m\n"], range_num=[1, len(name_and_links)])

print("\n\033[1;36m[1] \033[1;34mStream\033[0m\n\033[1;36m[2] \033[1;34mDownload\033[0m")

action = int_prompt("\033[1;35mSelect action:\033[0m ", ["\033[1;31mError: Invalid input\033[0m\n", "\033[1;31mError: Action out of range\033[0m\n"], range_num=[1, 2])

if action == 1:
	action = "stream"

elif action == 2:
	actiion = "download"

src_name = name_and_links[source][1]
src_link = name_and_links[source][0]

# Some source require fetching another sources and stream links and this code below handles it.
if src_link.startswith("/apivtwo"):
	src_link = src_link.replace("clock", "clock.json")
	resp = json.loads(urlopen("https://mblog.allanimenews.com" + src_link).read().decode())

	if src_name == "Ac": # Crunchyroll
		# Get subbed video (format: multitrack_adaptive_hls_v2)
		video_link = resp["links"]["portData"]["streams"][11]["url"]

	else:
		video_links = []

		for x in resp["links"]:

			# Skip HLS links because there is no built-in HLS handler at the moment
			if x["link"].endswith("m3u8"):
				continue

			else:
				video_links.append(x)

		if video_link == []:
			print("\033[1;31mUnsupported link format. Please use another source\033[0m")
			exit()

		if len(video_link) == 1:
			src_link = video_links[0]["link"]

		else:
			print("", end="\n")

			for x, y in enumerate(video_links, 1):
				print(f"\033[1;36m[{x}] \033[1;34m{y}\033[0m")

			another_src = int_prompt("\033[1;35mSelect source:\033[0m ", ["\033[1;31mError: Invalid input\033[0m\n", "\033[1;31mError: Source out of range\033[0m\n"], range_num=[1, len(video_links)])

			src_link = video_links[another_src-1]["link"]

if action == "stream":
	system(f"nohup am start --user 0 -a android.intent.action.VIEW -d '{src_link}' -n is.xyz.mpv/.MPVActivity > /dev/null 2>&1 &")
	print("\n\033[1;32mYou should see the MPV window shortly\033[0m")

else:
	download_url = name_and_links[source][2]

	if download_url is None:
		system(f"aria2c -s 7 -x 7 '{src_link}'")

	else:
		system(f"aria2c -s 7 -x 7 '{download_url['downloadUrl']}'")
