#!/usr/bin/env python
from urllib.request import urlopen, Request
from urllib.parse import quote as urlquote
from platform import python_version
from re import findall
from os import system
from json import loads as json_loads

# Input Sanitizer: Check if input value is valid and not out of range

def int_prompt(content, err_msgs, range_num=[]):

	while True:

		try:
			augh = int(input(content))
			break

		except ValueError:
			print(err_msgs[0])
			continue

		if range_num[0] <= augh <= range_num[1]:
			break

		else:
			print(err_msgs[1])
			continue

	return augh

def find_source(src_name, srcs):

	for x in srcs:

		if x[1] == src_name:
			link = x[0]
			break

	return [link, src_name]

# URL constants and SHA256 hashes for fetching query results and stream links
QUERY_HASH = "b645a686b1988327795e1203867ed24f27c6338b41e5e3412fc1478a8ab6774e"
STREAM_HASH = "0ac09728ee9d556967c1a60bbcf55a9f58b4112006d09a258356aeafe1c33889"

SEARCH_URL_VARIABLES = '{%22search%22:{%22query%22:%22<QUERY>%22,%22allowAdult%22:false,%22allowUnknown%22:false},%22limit%22:26,%22page%22:1,%22translationType%22:%22sub%22,%22countryOrigin%22:%22ALL%22}'
STREAM_URL_VARIABLES = '{%22showId%22:%22<ANIME_ID>%22,%22translationType%22:%22sub%22,%22episodeString%22:%22<EPISODE>%22}'

URL_EXTENSIONS = '{%22persistedQuery%22:{%22version%22:1,%22sha256Hash%22:%22<HASH>%22}}'

# START
query = input("\033[1;35mAnime name:\033[0m ")
print("", end="\n")
query = urlquote(query)

url_variables = SEARCH_URL_VARIABLES.replace("<QUERY>", query)
url_extensions = URL_EXTENSIONS.replace("<HASH>", QUERY_HASH)

fetch_url = "https://api.allanime.to/allanimeapi?variables=" + url_variables + "&extensions=" + url_extensions

# Fetch query reuslts and the anime info
resp = json_loads(urlopen(fetch_url).read().decode())
shows = resp["data"]["shows"]["edges"]

# List of AllAnime anime id's, name, and current subbed episode (used to fetch stream links and display anime's name to user)
ids_and_titles = [[z["_id"], z["name"], z["availableEpisodes"]["sub"]] for z in shows]

for x, y in enumerate(ids_and_titles, 1):
	print(f"\033[1;36m[{x}]\033[0m \033[1;34m{y[1]}\033[0m")

chosen_one = int_prompt("\033[1;35mSelect anime (with numbers):\033[0m ", ["\033[1;31mError: Invalid numbers\033[0m\n", "\033[1;31mError: Selection out of range\033[0m\n"], range_num=[1, len(ids_and_titles)])
chosen_one -= 1

# List of seleted anime ID's, name, and current subbed spisode
anime_info = ids_and_titles[chosen_one]

episode = int_prompt(f"\033[1;35mSelect episode [1-{anime_info[2]}]:\033[0m ", ["\033[1;31mError: Invalid input\033[0m\n", "\033[1;31mError: Episode out of range\033[0m\n"], range_num=[1, anime_info[2]])

# Replace URL templates with the corresponding inputs
url_variables = STREAM_URL_VARIABLES.replace("<ANIME_ID>", anime_info[0])
url_variables = url_variables.replace("<EPISODE>", str(episode))

url_extensions = URL_EXTENSIONS.replace("<HASH>", STREAM_HASH)

fetch_url = "https://api.allanime.to/allanimeapi?variables=" + url_variables + "&extensions=" + url_extensions

# Fetch and sort stream links
resp = json_loads(urlopen(fetch_url).read().decode())
stream_links = resp["data"]["episode"]["sourceUrls"]
stream_links = sorted(stream_links, key=lambda x: x['priority'], reverse=True)

# List of stream sources with their URL, name, and download link (if any)
name_and_links = [[z["sourceUrl"], z["sourceName"]] for z in stream_links]

print("\n\033[1;36m[1] \033[1;34mStream\033[0m\n\033[1;36m[2] \033[1;34mDownload\033[0m")

action = int_prompt("\033[1;35mSelect action:\033[0m ", ["\033[1;31mError: Invalid input\033[0m\n", "\033[1;31mError: Action out of range\033[0m\n"], range_num=[1, 2])

if action == 1:
	action = "stream"

elif action == 2:
	actiion = "download"

quality_table = {1: "1080", 2: "720", 3: "480", 4: "360"}

print("", end="\n")

for x in quality_table:
	print(f"\033[1;36m[{x}]\033[0m \033[1;34m{quality_table[x]}\033[0m")

quality = int_prompt("\033[1;35mSelect quality:\033[0m ", ["\033[1;31mError: Invalid input\033[0m\n", "\033[1;31mError: Quality out of range\033[0m\n"], range_num=[1, 4])
quality = quality_table[quality]

if quality == "1080":
	src_link, src_name = find_source("Yt-HD", name_and_links)

elif quality == "720" or quality == "360":
	src_link, src_name = find_source("Luf-mp4", name_and_links)

elif quality == "480":
	src_link, src_name = find_source("Yt-SD", name_and_links)

# Some source require fetching another sources and stream links and this code below handles it.
if src_link.startswith("/apivtwo"):
	src_link = src_link.replace("clock", "clock.json")
	req_obj = Request("https://mblog.allanimenews.com" + src_link, headers={"user-agent": f"Python/{python_version()}", "authority": "mblog.allanimenews.com"})
	resp = json_loads(urlopen(req_obj).read().decode())

	video_links = [x for x in resp["links"] if not x["link"].endswith("m3u8")]

	if video_links == []:
		print("\033[1;31mUnsupported link format. Please use another source\033[0m")
		exit()

	if len(video_links) == 1:
		is_hls = True
		src_link = video_links[0]["link"]

		req_obj = Request(src_link, headers={"user-agent": f"Python/{python_version()}"})
		resp = urlopen(req_obj).read().decode()
		resp = resp.split('\n')

		if quality == "360":
			src_link = resp[2]

		else:
			src_link = resp[6]

if action == "stream":
	system(f"nohup am start --user 0 -a android.intent.action.VIEW -d '{src_link}' -n is.xyz.mpv/.MPVActivity > /dev/null 2>&1 &")
	print("\n\033[1;32mYou should see the MPV window shortly\033[0m")

else:

	if is_hls is True:
		req_obj = Request(src_link, headers={"user-agent": f"Python/{python_version()}"})
		resp = urlopen(req_obj).read().decode()

		with open("dl.m3u8", "w") as file:
			file.write(resp)

		system(f"ffmpeg -loglevel error -stats -protocol_whitelist file,http,https,tcp,tls,crypto -i dl.m3u8 -c copy '{anime_info[0]} Episode {episode}.mp4'")

	else:
		system(f"aria2c -s 7 -x 7 -o '{anime_info[0]} Episode {episode}.np4' '{src_link}'")
